# About
I started programming when I was about 13 years old through the world of video games. After making a few small games myself I noticed that some aspects are present in each game, so I decided to make a library that would work on top of a framework I used back then called LOVE2D and would elevate the usage experience to be similar to a game engine. After that, I wanted to replace the underlying framework with my own, which I did. I implemented it in Go and while I do agree with the design of Go programming language, I was annoyed at times, so I ultimately decided to go for my own programming language where I could finally have exactly what I want.
One of the most important factors of making a language I would enjoy was making it easy. I do believe that everything should be straightforward; after all the programming languages are there to help overcome issues, not create them with their weird syntax or too abstract behaviour.
Becasue of that I started working my journey by attempting to create 3 interpreted languages. Every next one, I felt like I was a step closer and the experience overall felt really rewarding; I actually felt like I learn a lot during my little design and implementation trials.
Although I believe things should be easy I also believe in innovation. Just because something is unfamiliar, doesn't mean it is a bad design. I tried that aproach in my latest attempt at an interpreted language, which I named QIK. It was meant to be easy, but also very flexible, but talking about its precise goals and specifications is beyond the scope of this thesis.
The issue arise at the end of the project, which was rather unfortunate. One of the issue was the performance of the langauge itself; altough the interpreter was written in pure C, it was still unoptimized, so benchmarking it with Lua made the speed issue very apparent.
The other thing was the implementation itself; I did everything myself, that includes the parser and lexer. While I do not think this is not sometimes the right aproach, taking a look at this with my current knowledge makes me question my decisions. I wasn't really aware how lexers and parsers are supposed to work, so the implementation was really naive.
The last problem was definitely lack of memory management. It was a glairing issue in my original design of QIK. I could either fix that by writing a garbage collector (which would make it even slower) or just give up and state manual memory management which didn't fit the whole "being easy" narrative and is really incohirent with dynamic languages in my opinion, which are destined to be slower then statically typed solutions.
It just so happened that I was talking with my friends from US and one of them was implementing a compiler himself, so I asked how do I aproach this subject. Not a month later I had classes at my university about compilers, so the choice was really influenced by these two factors, thus making it more natural to go with the tools presented to me at the classes I took (even though I still remember I didn't have the best grade from that course, but to be honest it was really insightful).
The tools, namely flex and bison, solved the issue of poorly written lexer and parser by providing a working, well established alternative which even used my beloved C.
As for the performance issues, I listened to that one friend and decided to transpile to C and rely on the final C compiler in terms of optimization.
And with these in mind I started on implementing the language itself.